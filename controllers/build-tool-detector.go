/*

Package controllers is autogenerated
and containing scaffold outputs
as well as manually created sub-packages
and files.

*/
package controllers

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/goadesign/goa"
	"github.com/tinakurian/build-tool-detector/app"
	errs "github.com/tinakurian/build-tool-detector/controllers/error"
	"github.com/tinakurian/build-tool-detector/domain/buildtype"
	"github.com/tinakurian/build-tool-detector/domain/git"
	"github.com/tinakurian/build-tool-detector/domain/git/github"
	"github.com/tinakurian/build-tool-detector/domain/system"
	logorus "github.com/tinakurian/build-tool-detector/log"
)

var (
	// ErrFailedJSONMarshal unable to marshal json.
	ErrFailedJSONMarshal = errors.New("unable to marshal json")

	// ErrFailedPropagate unable to propagate error
	ErrFailedPropagate = errors.New("unable to propagate error")
)

const (
	errorz                      = "error"
	contentType                 = "Content-Type"
	applicationJSON             = "application/json"
	buildToolDetectorController = "BuildToolDetectorController"
)

// BuildToolDetectorController implements the build-tool-detector resource.
type BuildToolDetectorController struct {
	*goa.Controller
	ghClientID     string
	ghClientSecret string
}

// NewBuildToolDetectorController creates a build-tool-detector controller.
func NewBuildToolDetectorController(service *goa.Service, ghClientID string, ghClientSecret string) *BuildToolDetectorController {
	return &BuildToolDetectorController{Controller: service.NewController(buildToolDetectorController), ghClientID: ghClientID, ghClientSecret: ghClientSecret}
}

// Show runs the show action.
func (c *BuildToolDetectorController) Show(ctx *app.ShowBuildToolDetectorContext) error {
	rawURL := ctx.URL
	_, err := git.GetGitServiceType(rawURL)
	if err != nil {
		return handleError(ctx, err)
	}

	gitService := system.System{}.GetGitService()
	ctx.ResponseWriter.Header().Set(contentType, applicationJSON)
	buildToolType, err := gitService.GetGitHubService(c.ghClientID, c.ghClientSecret).GetContents(ctx.Context, rawURL, ctx.Branch)
	if err != nil {
		return handleError(ctx, err)
	}

	buildTool := buildtype.Unknown()
	if buildtype.MAVEN == *buildToolType {
		buildTool = buildtype.Maven()
	}
	return ctx.OK(buildTool)

}

func handleError(ctx *app.ShowBuildToolDetectorContext, err error) error {
	switch err.Error() {
	case github.ErrInvalidPath.Error():
		httpError := errs.ErrBadRequest(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.BadRequest()
	case github.ErrResourceNotFound.Error():
		httpError := errs.ErrNotFoundError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.NotFound()
	case github.ErrUnsupportedService.Error(),
		github.ErrUnsupportedGithubURL.Error():
		httpError := errs.ErrInternalServerError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.InternalServerError()
	case github.ErrFailedContentRetrieval.Error():
		buildTool := buildtype.Unknown()
		return ctx.OK(buildTool)
	default:
		return ctx.InternalServerError()
	}
}

func formatResponse(ctx *app.ShowBuildToolDetectorContext, httpTypeError *errs.HTTPTypeError) error {
	ctx.WriteHeader(httpTypeError.StatusCode)
	jsonHTTPTypeError, err := json.Marshal(httpTypeError)
	if err != nil {
		logorus.Logger().WithError(err).WithField(errorz, httpTypeError).Errorf(ErrFailedJSONMarshal.Error())
		return ctx.InternalServerError()
	}

	if _, err := fmt.Fprint(ctx.ResponseWriter, string(jsonHTTPTypeError)); err != nil {
		logorus.Logger().WithError(err).WithField(errorz, jsonHTTPTypeError).Errorf(ErrFailedPropagate.Error())
		return ctx.InternalServerError()
	}
	return nil
}
